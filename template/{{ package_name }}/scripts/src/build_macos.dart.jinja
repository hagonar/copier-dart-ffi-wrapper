/// Build {{ package_name }} for macOS.
///
/// Supports arm64, x86_64, or Universal Binary.
library;

import 'dart:io';

import 'common.dart';

/// Architecture to build for.
enum MacOSArch { arm64, x86_64, universal }

/// Build {{ package_name }} for macOS.
Future<void> buildMacOS({MacOSArch arch = MacOSArch.universal}) async {
  if (!Platform.isMacOS) {
    throw Exception('macOS build must be run on macOS');
  }

  printBuildHeader('macOS (${arch.name})');

  // Check dependencies
  logStep('Checking dependencies...');
  {% if wrapper_type == 'c' %}
  await requireCommand('cmake');
  await requireCommand('clang');

  final buildTool = await getBuildCommand();
  logInfo('Build tool: $buildTool');
  {% endif %}
  {% if wrapper_type == 'rust' %}
  await requireCommand('cargo');
  await requireCommand('rustup');
  {% endif %}

  // Get version
  final version = get{{ package_name | to_camel }}Version();
  logInfo('{{ native_library_name }} version: $version');

  // Setup directories
  final packageDir = getPackageDir();
  final tempDir = getTempBuildDir();
  final sourceDir = '$tempDir/{{ native_library_name }}';
  final outputDir = '${packageDir.path}/bin/macos';
  final flutterDir = '${packageDir.path}/macos/Libraries';

  // Clean and create temp directory
  logStep('Preparing build directory...');
  await removeDir(tempDir);
  await ensureDir(tempDir);

  // Clone source
  logStep('Downloading {{ native_library_name }} $version...');
  {% if wrapper_type == 'c' %}
  await gitClone(
    url: 'https://github.com/YOUR_ORG/{{ native_library_name }}.git',
    targetDir: sourceDir,
    branch: version,
  );
  {% endif %}
  {% if wrapper_type == 'rust' %}
  await cloneLibsignal(targetDir: sourceDir, version: version);
  {% endif %}

  // Build based on architecture
  await ensureDir(outputDir);

  if (arch == MacOSArch.universal) {
    {% if wrapper_type == 'c' %}
    final arm64Lib = await _buildArch(
      arch: 'arm64',
      deploymentTarget: '11.0',
      sourceDir: sourceDir,
      tempDir: tempDir,
      buildTool: buildTool,
    );

    final x86_64Lib = await _buildArch(
      arch: 'x86_64',
      deploymentTarget: '10.15',
      sourceDir: sourceDir,
      tempDir: tempDir,
      buildTool: buildTool,
    );
    {% endif %}
    {% if wrapper_type == 'rust' %}
    final arm64Lib = await buildLibsignalFfi(
      sourceDir: sourceDir,
      rustTarget: 'aarch64-apple-darwin',
    );
    final x86_64Lib = await buildLibsignalFfi(
      sourceDir: sourceDir,
      rustTarget: 'x86_64-apple-darwin',
    );
    {% endif %}

    // Create Universal Binary with lipo
    logStep('Creating Universal Binary...');
    await runCommandOrFail('lipo', [
      '-create',
      arm64Lib,
      x86_64Lib,
      '-output',
      '$outputDir/{{ lib_macos }}',
    ]);

    logInfo('Universal Binary architectures:');
    await runCommand('lipo', ['-info', '$outputDir/{{ lib_macos }}']);
  } else {
    {% if wrapper_type == 'c' %}
    final archName = arch == MacOSArch.arm64 ? 'arm64' : 'x86_64';
    final deploymentTarget = arch == MacOSArch.arm64 ? '11.0' : '10.15';

    final libPath = await _buildArch(
      arch: archName,
      deploymentTarget: deploymentTarget,
      sourceDir: sourceDir,
      tempDir: tempDir,
      buildTool: buildTool,
    );
    {% endif %}
    {% if wrapper_type == 'rust' %}
    final target = arch == MacOSArch.arm64
        ? 'aarch64-apple-darwin'
        : 'x86_64-apple-darwin';
    final libPath = await buildLibsignalFfi(
      sourceDir: sourceDir,
      rustTarget: target,
    );
    {% endif %}

    await copyFile(libPath, '$outputDir/{{ lib_macos }}');
  }

  // Fix install name
  logStep('Fixing install name...');
  await runCommandOrFail('install_name_tool', [
    '-id',
    '@rpath/{{ lib_macos }}',
    '$outputDir/{{ lib_macos }}',
  ]);

  // Copy to Flutter plugin directory
  logStep('Copying to Flutter plugin directory...');
  await ensureDir(flutterDir);
  await copyFile('$outputDir/{{ lib_macos }}', '$flutterDir/{{ lib_macos }}');

  // Cleanup
  logStep('Cleaning up...');
  await removeDir(tempDir);

  // Summary
  printBuildSummary('macOS ${arch.name}', outputDir);
}

{% if wrapper_type == 'c' %}
/// Build for a specific architecture.
Future<String> _buildArch({
  required String arch,
  required String deploymentTarget,
  required String sourceDir,
  required String tempDir,
  required String buildTool,
}) async {
  logPlatform(
    'macOS',
    'Building for $arch (deployment target: $deploymentTarget)...',
  );

  final buildDir = '$tempDir/build-macos-$arch';
  await ensureDir(buildDir);

  final cmakeArgs = [
    sourceDir,
    ...getBaseCMakeArgs(),
    '-DBUILD_SHARED_LIBS=ON',
    '-DCMAKE_OSX_ARCHITECTURES=$arch',
    '-DCMAKE_OSX_DEPLOYMENT_TARGET=$deploymentTarget',
    ...await getCMakeGeneratorArgs(),
  ];

  await runCommandOrFail('cmake', cmakeArgs, workingDirectory: buildDir);

  final buildArgs = await getBuildArgs();
  await runCommandOrFail(buildTool, buildArgs, workingDirectory: buildDir);

  return '$buildDir/lib/{{ lib_macos }}';
}
{% endif %}

/// Parse architecture from command line argument.
MacOSArch parseArch(String? arg) {
  switch (arg?.toLowerCase()) {
    case 'arm64':
      return MacOSArch.arm64;
    case 'x86_64':
    case 'x64':
    case 'intel':
      return MacOSArch.x86_64;
    case 'universal':
    case null:
      return MacOSArch.universal;
    default:
      throw Exception('Unknown architecture: $arg');
  }
}
